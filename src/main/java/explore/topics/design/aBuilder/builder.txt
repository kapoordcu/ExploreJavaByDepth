The builder pattern, as name implies, is an alternative way to construct complex objects. This should be used only when you want to build different immutable objects(with large set of state attributes.) using same object building process.


One way it to create more constructors, and another is to loose the immutability and introduce setter methods. You choose any of both options, you loose something, right?
Here, builder pattern will help you to consume additional attributes while retaining the immutability of User class.
Example in Java Project
This uses a additional class UserBuilder which helps us in building desired User object with all mandatory attributes and combination of optional attributes, without loosing the immutability.

Please note that above created user object does not have any setter method, so it’s state can not be changed once it has been built. This provides the desired immutability.


Let’s see how we can implement builder design pattern in java.
1.	First of all you need to create a static nested class and then copy all the arguments from the outer class to the Builder class.
2.	Builder class should have a public constructor with all the required attributes as parameters.
3.	Builder class should have methods to set the optional parameters and it should return the same Builder object after setting the optional attribute.
4.	The final step is to provide a build() method in the builder class that will return the Object needed by client program. For this we need to have a private constructor in the Class with Builder class as argument.

Builder Design Pattern Example in JDK
Some of the builder pattern example in Java classes are;
•	java.lang.StringBuilder#append() (unsynchronized)
•	java.lang.StringBuffer#append() (synchronized)
When to use ?

•	Use the Builder pattern to get rid of a “telescopic constructor”.
•	Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

Benefits and Advantages of Builder Pattern
Undoubtedly, the number of lines of code increase at least to double in builder pattern, but the effort pays off in terms of design flexibility and much more readable code. The parameters to the constructor are reduced and are provided in highly readable method calls.
Builder pattern also helps minimizing the number of parameters in constructor and thus there is no need to pass in null for optional parameters to the constructor.
Another advantage is that Object is always instantiated in a complete state rather than sitting in an incomplete state until the developer calls (if ever calls) the appropriate “setter” method to set additional fields.
It provides better control over construction process.
It supports to change the internal representation of objects.

Costs and Disadvantages of Builder Pattern
Though Builder pattern reduce some line of code by eliminating the need of setter methods, still in double up total lines by introducing the Builder object.
Furthermore, although client code is more readable, the client code is also more verbose.


Compare with other patterns

Builder pattern was introduced to solve some of the problems with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.

https://refactoring.guru/design-patterns/builder

There are three major issues with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.
1.	Too Many arguments to pass from client program to the Factory class that can be error prone because most of the time, the type of arguments are same and from client side its hard to maintain the order of the argument.
2.	Some of the parameters might be optional but in Factory pattern, we are forced to send all the parameters and optional parameters need to send as NULL.
3.	If the object is heavy and its creation is complex, then all that complexity will be part of Factory classes that is confusing.
We can solve the issues with large number of parameters by providing a constructor with required parameters and then different setter methods to set the optional parameters. The problem with this approach is that the Object state will be inconsistent until unless all the attributes are set explicitly.

Builder pattern solves the issue with large number of optional parameters and inconsistent state by providing a way to build the object step-by-step and provide a method that will actually return the final Object.

